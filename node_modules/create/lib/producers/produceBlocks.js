import { getUpdatedBlockAddons, } from "../mergers/getUpdatedBlockAddons.js";
import { mergeCreations } from "../mergers/mergeCreations.js";
import { produceBlock } from "./produceBlock.js";
export function produceBlocks(blocks, { addons, mode, offline, options, system }) {
    // From engine/runtime/execution.md:
    // This engine continuously re-runs Blocks until no new Args are provided.
    const blockProductions = new Map(addons?.map((addon) => [addon.block, { addons: addon.addons }]));
    // 1. Create a queue of Blocks to be run, starting with all defined in the Preset
    const allowedBlocks = new Set(blocks);
    const blocksToBeRun = new Set(blocks);
    // 2. For each Block in the queue:
    while (blocksToBeRun.size) {
        for (const currentBlock of blocksToBeRun) {
            blocksToBeRun.delete(currentBlock);
            // 2.1. Get the Creation from the Block, passing any current known Addons
            // 2.2. If a mode is specified, additionally generate the appropriate Block Creations
            const previousProduction = blockProductions.get(currentBlock);
            const previousAddons = previousProduction?.addons ?? {};
            const blockCreation = produceBlock(currentBlock, {
                ...system,
                addons: previousAddons,
                mode,
                offline,
                options,
            });
            // 2.3. Store that Block's Creation
            blockProductions.set(currentBlock, {
                addons: previousAddons,
                creation: blockCreation,
            });
            // 2.4. If the Block specified new addons for any defined Blocks:
            const updatedBlockAddons = getUpdatedBlockAddons(allowedBlocks, blockProductions, blockCreation.addons);
            // 2.4.1: Add those Blocks to the queue to re-run
            for (const [updatedBlock, updatedAddons] of updatedBlockAddons) {
                const addedBlockPreviousProduction = blockProductions.get(updatedBlock);
                blockProductions.set(updatedBlock, {
                    ...addedBlockPreviousProduction,
                    addons: updatedAddons,
                });
                blocksToBeRun.add(updatedBlock);
            }
        }
    }
    // 3. Merge all Block Creations together
    return Array.from(blockProductions.values()).reduce((created, next) => mergeCreations(created, next.creation ?? {}), {});
}
//# sourceMappingURL=produceBlocks.js.map